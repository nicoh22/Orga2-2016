Los filtros a implementar, mencionados en la introduccion, son tres:
 
\begin{enumerate}
\item Cropflip
\item Sepia
\item Low dynamic range 
\end{enumerate}
\subsection{Cropflip}
Este filtro es una union de dos filtros: crop y vertical-flip. Recorta una parte de la imagen original y la voltea verticalmente. Para ello recibe cuatro argumento delimitando un rectongulo de la imagen a cual aplicar el filtro, las posiciones de las coordenadas se obtienen desde abajo hacia arriba:
\begin{itemize}
\item{tamx: este posee la cantidad de columnas, en pixeles, a recortar. Este numero es multiplo de 4.}
\item{tamy: contiene la cantidad de filas, en pixeles, a recortar.}
\item{offseex: con la columna, en pixeles, a partir de la cual debe comenzar a recortarse. Este numero tambien es multiplo de 4.}
\item{offsety: fila, en pixeles, a partir de la cual debe comenzar a recortarse.}
\end{itemize}
 El filtro recorta un rectangulo de {\boldmath $ tamx $} pixeles de ancho por {\boldmath $ tamy $} pixeles de alto a partir de
la columna {\boldmath $ offsetx $} fila {\boldmath $ offsety $} y lo pega en la imagen destino, espejado verticalmente. Para ello rearma las filas en orden inverso.\\
Al utilizar SIMD este filtro puede procesar de a 4 pixeles, por lo que logra un resultado con un menor numero de operaciones.\\ 
 Tomando entonces de a 4 pixeles desde el inicio del rectangulo determinado por los parametro, rearma la imagen comenzando desde el inicio de la ultima fila de la matriz destino, logrando finalmente, al recorrer todas las filas, el espejado vertical esperado
\subsection{Sepia}
Esta operacion consiste en cambiar la informacion de color de cada pixel de la siguiente manera:

$$O_{i,j}^{R} = 0, 5 . suma_{i,j}$$
$$O_{i,j}^{G} = 0, 3 . suma_{i,j}$$
$$O_{i,j}^{B} = 0, 2 . suma_{i,j}$$
donde $suma_{i,j} = I_{i,j}^{R} + I_{i,j}^{G} + I_{i,j}^{B}$
\subsection{Low Dynamic Range}
El filtro LDR toma una imagen fuente y aplica un efecto que modifica la imagen segun su iluminacion. El filtro toma el valor de un pixel y le añade un porcentaje $\alpha$ de el de sus vecinos.
De esta manera, dado un porcentaje positivo, los pıxeles rodeados por pıxeles claros se vuelven
aun mas claros, mientras que los rodeados por pixeles oscuros se mantienen igual. La intensidad
del efecto dependera del porcentaje sumado.
Para cada componente independiente del pixel (R, G y B) la formula matematica sera

$$O_{i,j}^{K} = min(max(ldr_{i,j}^{K},0),255)$$
donde
$$ldr_{i,j}^{K} = I_{i,j}^{K} + \alpha \frac{sumargb_{i,j}}{max} . I_{i,j}^{K}$$
$$sumargb_{i,j} = suma_{i,j}^{r} + suma_{i,j}^{g} + suma_{i,j}^{b}$$
$$max = 5*5*255*3*255$$
y finalmente $suma_{i,j}^{K}$ corresponde a:



Para reducir errores de redondeo, la division debe ser la ultima operacion en realizarse.
Notar que las operaciones mın y max se pueden pensar como que x satura en 255.
Ademas, dado que en los bordes no es posible calcular ldr por la ausencia de vecinos, debera
escribirse en esos casos el valor original del pixel. Es decir,
$$O_{i,j}^{K} = I_{i,j}^{K} si i<2 \vee j<2 \vee i+2 \leq tamy \vee j +2 \leq tmax$$
(con i indexado a partir de 0)
\subsection{Analisis experimental y metodologias}
En esta seccion comentaremos nuestras hipotesis, como las abordamos y los resultado obtenidos. Evaluaremos con los distintos tests el rendimiento de cada implementacion, el mejor o peor rendimiento de las implementaciones se basa en la toma de tiempos de ejecucion. Como los tiempo de ejecucion son muy pequeños, se utilizara uno de los contadores de performance que posee el procesador.\\ Es posible q en nuestras experimentaciones se obtengan valores atipicos o outliers, por esta razon tomaremos para cada corrida de mas de una iteracion, una medida $\alpha = 0.5$ a derecha solamente, logrando evitar asi lo valores mas distantes.\\
%\ref{fig:starwars}
%mencionar la imagen: es una de star wars. Si te puleas la vas a ver en img/SW
%la agregas al pdf. Emoticón tongue
%Y los datos del procesador. que te los pasamos
%deja un espacio para eso.
A continuacion separaremos nuestras hipotesis por los tests desarrollados:

Test 0:\\
Nuestra primer hipotesis es sobre las diferencias en cuanto al rendimiento de los filtros para distintas imagenes.\\
En esta experimentacion aplicamos los filtros tanto en asm como en c para varias imagenes de distintos tamaños. Segun nuestra hipotesis,con un aumento de forma cuadratica en el tamaño de las imagenes se obtiene una curva cuadratica, pero dado q las imagenes utilizadas poseen mas altura q ancho, la curva resultante se asimilaria mas a una recta. Luego, en base a esto, planteamos que para el filtro de LDR, que con un aumento solo en el ancho de la imagen, la curva resultante seria una recta(..).\\Luego, aplicando el filtro LDR, observaremos que aumentando tan solo el alto se obtendra una aproximacion a una recta, y al aumentar mas el ancho que la altura de la imagen se obtendra una curva cuadratica. Se podria expresar matematicamente diciendo que $res=a*x^2$ con $a>1$ siendo a el alto o ancho de la imagen

%La hipotesis va a ser que para aumentos cuadraticos la curva deberia ser cuadratica. Pero como la imagen que voy a usar es mas alta que ancha, la curva resultante esta planchada
%casi. Luego en base a esto mostramos solo para ldr que si aumetas solo el ancho te deberia dar una recta (no se lo que da todavia) y que si aumentas mas ancho que alto deberia dar mas cuadratico (se habla aca de que a*x^2 tiene a > 1)
%y el a ese es que tan alta o ancha es la imagen
%(parece que influye. cuando obtengamos los resultados te comento)
%podes meter algo de sarasa pero esa parte extra sobre el test 0 esta sin concluir


Test 1:\\En este tes pondremos a prueba una hipotesis sobre el rendimiento con SIMD, esta consiste en que utilizando en nuestros filtros el procesamiento de informacion a traves de SIMD en el lenguaje assembler, lograremos un mejor rendimiento que aplicandolos sobre el lenguaje c o en c optimizado.
\\Para su experimentacion realizamos x corridas para cada filtro en los distintos lenguajes.

%Test 1: asm simd es mejor que c y c optimizado? pues bien. Vamos a hacer corridas para cada filtro y mostrar que asi es en realidad. Tenes que mencionar la cantidad de corridas por cada filtro e implementacion. Pone X, despues te pasamos ese dato correctamente.
%Entonces. Corremos para cada filtro todas las implementacions: ASM, C, C con O3
%y generamos un grafico de barras
%comparando las tres implementaciones
%deducimos lo obvio



Test 2:\\
Este test es sobre el papel que juega la cache con nuestro filtro cropflip. Nuestra hipotesis es sobre la cantidad de hits y miss que se produciran modificando el tamaño de la image.
%Test 2:
%es el de cache. Para testear la cache lo que vamos a hacer es agarrar la imagen de star wars orignal. la mas grande. y cortar 16x2144 hasta 2144x16
%con offset en x de 16
%la cosa da constante
%parece que no afecta la cache
%Vamos a tratar de pasarte los valores de misses de la cache l1 data y ll data
%son iguales en todos los casos parece


Test 3:\\
En este test planteamos dos hipotesis para el filtro LDR:


a)La primera de nuestras hipotesis es sobre el rendimiento entre asm y c, plantea que si igualamos la cantidad de accesos a memoria de ambas implementaciones tanto en lectura como escritura (ya que en un principio la implementacion en c posee una mayor cantidad de accesos a memoria) obtenemos de todas formas que la implementacion en asm es mas eficiente q la implementada en c.

b)Por ultimo, comparamos asm con asm, uno con operaciones en punto flotante y el otro con operaciones con enteros, la hipotesis inicial de este test es que la implementacion que opera con enteros es mas eficiente q la implementada con operaciones a punto flotantes, dado que es mas simple su manipulacion.
%Test 3: sobre ldr.
%este test esta bueno. Comparamos corridas de Asm contra C igualando en Asm la cantidad de accesos a memoria (tanto para leer como para escribir)
%generamos un grafico de barras comparando los resultados
%da claramente mejor asm para X iteraciones por cada implementacion
%luego comparo asm con ops de punto flotante contra ops de enteros
%gana con ops de punto flotante.
