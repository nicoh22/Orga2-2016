Para cada filtro e implementación ($assembler$ $SIMD$, $C-O1$ y $C-O3$): Se procesa la imágen $lena32.bmp$ 100 veces, se divide el resultado de cada muestra por el tamaño de la imágen (512x512) y se calcula el promedio intercuartil y su desvio estandar

\begin{figure}[h]
  \begin{center}
	\includegraphics[scale=0.5]{ldrClocks.pdf}
	%\caption{La última de Star Wars}
  \end{center}
\end{figure}

\begin{figure}[h]
  \begin{center}
	\includegraphics[scale=0.5]{sepiaClocks.pdf}
	%\caption{La última de Star Wars}
  \end{center}
\end{figure}

\newpage

\begin{figure}
  \begin{center}
	\includegraphics[scale=0.5]{cropflipClocks.pdf}
	%\caption{La última de Star Wars}
  \end{center}
\end{figure}

Como puede observarse, salvo en el caso del filtro $cropflip$, el flag de optimización $O3$ no supone una ventaja sobre $O1$ pero la implementación en $assembler$ $SIMD$ logra una buena performance en comparación. 

Al contrario, en $cropflip$ puede observarse que $O3$ está muy cerca de $assembler$ $SIMD$ con lo cual nuestra conclusion es que dependiendo del filtro o tarea que querramos realizar el compilador podrá optimizar más o menos y será cuestion del desarrollador evaluar si es necesario realizar el código en $assembler$ $SIMD$ sin ayuda del compilador.
